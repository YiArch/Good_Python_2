<html>
 <head></head>
 <body>
  <p>Видео-разбор подвига (решение смотреть только после своей попытки): <a href="https://youtu.be/5Y9qT5grunw" rel="noopener noreferrer nofollow">https://youtu.be/5Y9qT5grunw</a></p> 
  <p><strong>Большой подвиг 8.</strong> Требуется реализовать программу по работе с решающими деревьями:</p> 
  <p style="text-align: center;"><img alt="" height="317" name="решающее дерево.png" src="https://ucarecdn.com/aba1d29f-550a-4dba-89f5-df4164284478/" width="713"></p> 
  <p>Здесь в каждом узле дерева делается проверка (задается вопрос). Если проверка проходит, то осуществляется переход к следующему объекту по левой стрелке (с единицей), а иначе - по правой стрелке (с нулем). И так до тех пор, пока не дойдем до одного из листа дерева (вершины без потомков).</p> 
  <p>В качестве входных данных будет использоваться вектор (список) с бинарными значениями: 1 - да, 0 - нет. Каждый элемент этого списка соответствует своему вопросу, например:</p> 
  <p style="text-align: center;"><img alt="" height="138" name="решающее дерево x.png" src="https://ucarecdn.com/a81ebcd0-ba44-43c9-bfae-34f27bc672e1/" width="537"></p> 
  <p>Для реализации решающих деревьев в программе следует объявить два класса:</p> 
  <p><strong>TreeObj </strong>- для описания вершин и листьев решающего дерева;<br> <strong>DecisionTree</strong> - для работы с решающим деревом в целом.</p> 
  <p>В классе DecisionTree должны быть реализованы (по крайне мере) два метода уровня класса (@classmethod):</p> 
  <p><u>def predict(cls, root, x)</u> - для построения прогноза (прохода по решающему дереву) для вектора x из корневого узла дерева root.<br> <u>def add_obj(cls, obj, node=None, left=True)</u> - для добавления вершин в решающее дерево;</p> 
  <p>В методе add_obj параметры имеют, следующие значения:</p> 
  <p>obj - ссылка на новый (добавляемый) объект решающего дерева;<br> node - ссылка на объект дерева, к которому присоединяется вершина obj;<br> left - флаг, определяющий ветвь дерева (объекта node), к которой присоединяется объект obj (True - к левой ветви; False - к правой).</p> 
  <p>В классе <strong>TreeObj</strong> следует объявить инициализатор:</p> 
  <p>def __init__(self, indx, value=None): ...</p> 
  <p>где <u>indx</u> - проверяемый в вершине дерева индекс вектора x; <u>value</u> - значение, хранящееся в вершине (для промежуточных вершин None).</p> 
  <p>При этом, в каждом создаваемом объекте класса TreeObj должны автоматически появляться следующие локальные атрибуты:</p> 
  <p>indx - проверяемый индекс (целое число);<br> value - значение с данными (строка);<br> __left - ссылка на следующий объект дерева по левой ветви (изначально None);<br> __right - ссылка на следующий объект дерева по правой ветви (изначально None).</p> 
  <p>Для работы с локальными приватными атрибутами __left и __right необходимо объявить объекты-свойства с именами <strong>left </strong>и <strong>right</strong>.</p> 
  <p>Эти классы в дальнейшем предполагается использовать следующим образом (эти строчки в программе не писать):</p> 
  <pre><code>root = DecisionTree.add_obj(TreeObj(0))
v_11 = DecisionTree.add_obj(TreeObj(1), root)
v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)

x = [1, 1, 0]
res = DecisionTree.predict(root, x) # будет программистом</code></pre> 
  <p>P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.&nbsp;</p>
 </body>
</html><br><br><font color="gray">Memory limit: 256 MB</font><br><font color="gray">Time limit: 15 seconds</font><br><br>